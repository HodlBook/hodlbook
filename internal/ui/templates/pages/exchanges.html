{{define "content"}}
<div class="exchanges-page">
    <section class="page-header">
        <div class="page-header-actions">
            <button class="btn btn-secondary"
                hx-post="/partials/exchanges/refresh-prices"
                hx-target="#exchanges-table-container"
                hx-swap="innerHTML">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <path d="M3 3v5h5"/>
                    <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/>
                    <path d="M16 16h5v5"/>
                </svg>
                Refresh Prices
            </button>
            <button class="btn btn-primary" @click="$dispatch('open-add-exchange')">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12h14"/>
                </svg>
                Add Exchange
            </button>
        </div>
    </section>

    <section class="exchanges-filters">
        <div class="card">
            <div class="card-body filters-row">
                <div class="filter-group">
                    <label>From Symbol</label>
                    <select name="from_symbol" class="form-control"
                        hx-get="/partials/exchanges/table"
                        hx-target="#exchanges-table-container"
                        hx-include=".filters-row select, .filters-row input">
                        <option value="">All Symbols</option>
                        {{range .Symbols}}
                        <option value="{{.}}">{{.}}</option>
                        {{end}}
                    </select>
                </div>
                <div class="filter-group">
                    <label>To Symbol</label>
                    <select name="to_symbol" class="form-control"
                        hx-get="/partials/exchanges/table"
                        hx-target="#exchanges-table-container"
                        hx-include=".filters-row select, .filters-row input">
                        <option value="">All Symbols</option>
                        {{range .Symbols}}
                        <option value="{{.}}">{{.}}</option>
                        {{end}}
                    </select>
                </div>
                <div class="filter-group">
                    <label>From</label>
                    <input type="date" name="from" class="form-control"
                        hx-get="/partials/exchanges/table"
                        hx-target="#exchanges-table-container"
                        hx-trigger="change"
                        hx-include=".filters-row select, .filters-row input">
                </div>
                <div class="filter-group">
                    <label>To</label>
                    <input type="date" name="to" class="form-control"
                        hx-get="/partials/exchanges/table"
                        hx-target="#exchanges-table-container"
                        hx-trigger="change"
                        hx-include=".filters-row select, .filters-row input">
                </div>
            </div>
        </div>
    </section>

    <section class="exchanges-list" x-data="exchangeSelection()">
        <div class="card">
            <div class="card-body">
                <div id="exchanges-table-container" hx-get="/partials/exchanges/table" hx-trigger="load" hx-swap="innerHTML" @htmx:after-swap="clearSelection()">
                    <div class="skeleton-table">
                        <div class="skeleton-row"><div class="skeleton text"></div><div class="skeleton text"></div><div class="skeleton text"></div><div class="skeleton text"></div></div>
                        <div class="skeleton-row"><div class="skeleton text"></div><div class="skeleton text"></div><div class="skeleton text"></div><div class="skeleton text"></div></div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <div x-data="exchangeModal()" @open-add-exchange.window="openAdd()" @open-edit-exchange.window="openEdit($event.detail)" @close-modal.window="open = false">
        <div x-show="open" x-cloak class="modal-overlay" @click.self="open = false" @keydown.escape.window="open = false">
            <div class="modal modal-lg" x-transition>
                <div class="modal-header">
                    <h2 class="modal-title" x-text="isEdit ? 'Edit Exchange' : 'Add Exchange'"></h2>
                    <button type="button" @click="open = false" class="modal-close">&times;</button>
                </div>
                <form id="exchange-form"
                      :hx-post="isEdit ? '/partials/exchanges/update/' + exchangeId : '/partials/exchanges/create'"
                      hx-target="#exchanges-table-container"
                      hx-swap="innerHTML"
                      @htmx:after-request="if(event.detail.successful) { open = false; refreshHoldings(); $dispatch('show-toast', {message: isEdit ? 'Exchange updated' : 'Exchange added', type: 'success'}) }">
                    <div class="modal-body">
                        <div class="exchange-section">
                            <div class="exchange-section-header">
                                <span class="badge badge-danger">From</span>
                                <span class="usd-hint" x-show="fromUsd > 0" x-text="'~$' + formatUsd(fromUsd)"></span>
                            </div>
                            <div class="form-group" x-data="cryptoSearchFrom()" x-init="$watch('fromSymbol', v => { search = v; })">
                                <label>Symbol <span class="required">*</span></label>
                                <div class="crypto-select" @click.outside="showDropdown = false">
                                    <input type="text" name="from_symbol" class="form-control" required
                                        x-model="search" placeholder="Search asset..."
                                        @input="onInput($event.target.value)"
                                        @focus="onFocus()"
                                        @keydown.arrow-down.prevent="highlightNext()"
                                        @keydown.arrow-up.prevent="highlightPrev()"
                                        @keydown.enter.prevent="selectHighlighted()"
                                        @keydown.escape="showDropdown = false"
                                        autocomplete="off">
                                    <div class="crypto-dropdown" x-show="showDropdown && filteredAssets.length > 0" x-cloak>
                                        <template x-for="(asset, index) in filteredAssets" :key="asset.symbol">
                                            <div class="crypto-option"
                                                :class="{ 'highlighted': index === highlightedIndex }"
                                                @click="selectAsset(asset)"
                                                @mouseenter="highlightedIndex = index">
                                                <span class="crypto-symbol" x-text="asset.symbol"></span>
                                                <span class="crypto-name" x-text="$data.formatNumber(asset.amount)"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                <small class="form-hint">
                                    <span x-show="fromSymbol && holdings[fromSymbol]" x-text="'Available: ' + formatNumber(holdings[fromSymbol] || 0)"></span>
                                    <span x-show="fromSymbol && availableUsd > 0" x-text="' (~$' + formatUsd(availableUsd) + ')'"></span>
                                    <span x-show="fromSymbol && fromSymbolUsdPrice > 0" x-text="' | Price: $' + formatUsd(fromSymbolUsdPrice)"></span>
                                </small>
                            </div>
                            <div class="form-group">
                                <label>Amount <span class="required">*</span></label>
                                <input type="number" name="from_amount" class="form-control"
                                    step="any" min="0" required x-model="fromAmount" @input="calcRate()" placeholder="0.00">
                            </div>
                        </div>

                        <div class="exchange-arrow">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M7 16V4m0 0L3 8m4-4l4 4M17 8v12m0 0l4-4m-4 4l-4-4"/>
                            </svg>
                            <span class="exchange-rate" x-show="exchangeRate > 0" x-text="'1 ' + toSymbol + ' = ' + formatRate(exchangeRate) + ' ' + fromSymbol"></span>
                        </div>

                        <div class="exchange-section">
                            <div class="exchange-section-header">
                                <span class="badge badge-success">To</span>
                                <span class="usd-hint" x-show="toUsd > 0" x-text="'~$' + formatUsd(toUsd)"></span>
                                <span class="value-hint" x-show="toValueInFrom > 0" x-text="'= ' + formatNumber(toValueInFrom) + ' ' + fromSymbol"></span>
                            </div>
                            <div class="form-group" x-data="cryptoSearchTo()" x-init="$watch('toSymbol', v => { search = v; onSymbolSelected(v); })">
                                <div class="label-with-hint">
                                    <label>Symbol <span class="required">*</span></label>
                                    <span class="crypto-name-hint" x-show="toSymbolCoinId" x-text="toSymbolCoinId"></span>
                                </div>
                                <div class="crypto-select" @click.outside="showDropdown = false">
                                    <input type="text" name="to_symbol" class="form-control" required
                                        x-model="search" placeholder="Search by symbol or name..."
                                        @input="onInput($event.target.value)"
                                        @focus="onFocus()"
                                        @keydown.arrow-down.prevent="highlightNext()"
                                        @keydown.arrow-up.prevent="highlightPrev()"
                                        @keydown.enter.prevent="selectHighlighted()"
                                        @keydown.escape="showDropdown = false"
                                        autocomplete="off">
                                    <div class="crypto-dropdown" x-show="showDropdown && filteredCryptos.length > 0" x-cloak>
                                        <template x-for="(crypto, index) in filteredCryptos" :key="crypto.symbol">
                                            <div class="crypto-option"
                                                :class="{ 'highlighted': index === highlightedIndex }"
                                                @click="selectCrypto(crypto)"
                                                @mouseenter="highlightedIndex = index">
                                                <span class="crypto-symbol" x-text="crypto.symbol"></span>
                                                <span class="crypto-name" x-text="crypto.name"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </div>
                            <div class="form-group">
                                <div class="label-with-hint">
                                    <label>Price <span x-show="fromSymbol" x-text="'(' + fromSymbol + ')'"></span></label>
                                    <a class="usd-hint"
                                        x-show="toSymbolUsdPrice > 0 && toSymbolCoinId"
                                        :href="'https://www.coingecko.com/en/coins/' + toSymbolCoinId"
                                        target="_blank"
                                        x-text="'$' + formatUsd(toSymbolUsdPrice)"></a>
                                </div>
                                <input type="number" name="to_price" class="form-control"
                                    step="any" min="0" x-model="toPrice" placeholder="0.00">
                                <button type="button" class="btn btn-sm btn-secondary mt-1"
                                    x-show="canCalcToPrice"
                                    @click="calcToPrice()"
                                    x-text="'Calc ' + toSymbol + ' price'">
                                </button>
                            </div>
                            <div class="form-group">
                                <label>Amount <span class="required">*</span></label>
                                <input type="number" name="to_amount" class="form-control"
                                    step="any" min="0" required x-model="toAmount" @input="calcRate()" placeholder="0.00">
                                <button type="button" class="btn btn-sm btn-secondary mt-1"
                                    x-show="canCalcToAmount"
                                    @click="calcToAmount()"
                                    x-text="'Calc ' + toSymbol + ' amount'">
                                </button>
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label>Fee</label>
                                <input type="number" name="fee" class="form-control"
                                    step="any" min="0" x-model="fee" placeholder="0.00">
                            </div>
                            <div class="form-group">
                                <label>Fee Currency</label>
                                <input type="text" name="fee_currency" class="form-control"
                                    x-model="feeCurrency" placeholder="e.g., USDT">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Date <span class="required">*</span></label>
                            <input type="datetime-local" name="timestamp" class="form-control" required x-model="timestamp">
                        </div>
                        <div class="form-group">
                            <label>Notes</label>
                            <textarea name="notes" class="form-control" rows="2" x-model="notes" placeholder="Optional notes..."></textarea>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" @click="open = false" class="btn btn-secondary">Cancel</button>
                        <button type="submit" class="btn btn-primary" x-text="isEdit ? 'Update' : 'Add'"></button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div x-data="deleteExchangeModal()" @open-delete-exchange.window="openDelete($event.detail)" @keydown.escape.window="open = false">
        <div x-show="open" x-cloak class="modal-overlay" @click.self="open = false">
            <div class="modal modal-sm" x-transition>
                <div class="modal-header">
                    <h2 class="modal-title">Delete Exchange</h2>
                    <button @click="open = false" class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete this exchange?</p>
                </div>
                <div class="modal-footer">
                    <button @click="open = false" class="btn btn-secondary">Cancel</button>
                    <button @click="confirmDelete()" class="btn btn-danger">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <div x-data="bulkDeleteExchangeModal()" @open-bulk-delete-exchanges.window="openBulkDelete()" @keydown.escape.window="open = false">
        <div x-show="open" x-cloak class="modal-overlay" @click.self="open = false">
            <div class="modal modal-sm" x-transition>
                <div class="modal-header">
                    <h2 class="modal-title">Delete Selected Exchanges</h2>
                    <button @click="open = false" class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete <strong x-text="count"></strong> selected exchanges?</p>
                </div>
                <div class="modal-footer">
                    <button @click="open = false" class="btn btn-secondary">Cancel</button>
                    <button @click="confirmBulkDelete()" class="btn btn-danger">Delete All</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let cachedExchangeCryptos = null;
let selectedExchangesStore = [];

function exchangeSelection() {
    return {
        selectedExchanges: selectedExchangesStore,
        get allExchangesSelected() {
            const checkboxes = document.querySelectorAll('#exchanges-table-container .row-checkbox');
            return checkboxes.length > 0 && this.selectedExchanges.length === checkboxes.length;
        },
        toggleExchange(id, checked) {
            if (checked) {
                if (!this.selectedExchanges.includes(id)) {
                    this.selectedExchanges.push(id);
                }
            } else {
                this.selectedExchanges = this.selectedExchanges.filter(i => i !== id);
            }
            selectedExchangesStore = this.selectedExchanges;
        },
        toggleAllExchanges(checked) {
            const checkboxes = document.querySelectorAll('#exchanges-table-container .row-checkbox');
            if (checked) {
                this.selectedExchanges = Array.from(checkboxes).map(cb => parseInt(cb.value));
            } else {
                this.selectedExchanges = [];
            }
            selectedExchangesStore = this.selectedExchanges;
        },
        clearSelection() {
            this.selectedExchanges = [];
            selectedExchangesStore = [];
        }
    }
}

function bulkDeleteExchangeModal() {
    return {
        open: false,
        count: 0,
        openBulkDelete() {
            this.count = selectedExchangesStore.length;
            if (this.count > 0) {
                this.open = true;
            }
        },
        confirmBulkDelete() {
            fetch('/partials/exchanges/bulk-delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ids: selectedExchangesStore })
            }).then(response => {
                this.open = false;
                selectedExchangesStore = [];
                refreshHoldings();
                return response.text();
            }).then(html => {
                document.getElementById('exchanges-table-container').innerHTML = html;
            });
        }
    }
}

async function fetchExchangeCryptos() {
    if (cachedExchangeCryptos) return cachedExchangeCryptos;
    try {
        const response = await fetch('/api/ui/cryptos');
        cachedExchangeCryptos = await response.json();
        return cachedExchangeCryptos;
    } catch (e) {
        console.error('Failed to fetch cryptos:', e);
        return [];
    }
}

function getCryptoPrice(symbol) {
    if (!cachedExchangeCryptos || !symbol) return 0;
    const crypto = cachedExchangeCryptos.find(c => c.symbol === symbol);
    return crypto ? crypto.price : 0;
}

function getCryptoCoinId(symbol) {
    if (!cachedExchangeCryptos || !symbol) return '';
    const crypto = cachedExchangeCryptos.find(c => c.symbol === symbol);
    return crypto ? crypto.name : '';
}

function cryptoSearchFrom() {
    return {
        search: '',
        assets: [],
        filteredAssets: [],
        showDropdown: false,
        highlightedIndex: 0,
        init() {
            this.refreshAssets();
            window.addEventListener('holdings-updated', () => this.refreshAssets());
        },
        refreshAssets() {
            this.assets = Object.keys(holdingsData)
                .filter(symbol => holdingsData[symbol] > 0)
                .map(symbol => ({ symbol, amount: holdingsData[symbol] }))
                .sort((a, b) => a.symbol.localeCompare(b.symbol));
        },
        onFocus() {
            this.filterAssets();
            this.showDropdown = true;
            this.highlightedIndex = 0;
        },
        onInput(value) {
            this.search = value.toUpperCase();
            this.filterAssets();
            this.highlightedIndex = 0;
        },
        filterAssets() {
            if (!this.search) {
                this.filteredAssets = this.assets.slice(0, 10);
                return;
            }
            const term = this.search.toLowerCase();
            this.filteredAssets = this.assets
                .filter(a => a.symbol.toLowerCase().includes(term))
                .slice(0, 10);
        },
        selectAsset(asset) {
            this.search = asset.symbol;
            this.$data.fromSymbol = asset.symbol;
            this.$data.fromSymbolUsdPrice = getCryptoPrice(asset.symbol);
            this.recalcToPrice();
            this.showDropdown = false;
        },
        recalcToPrice() {
            const toUsdPrice = this.$data.toSymbolUsdPrice || 0;
            const fromUsdPrice = this.$data.fromSymbolUsdPrice || 0;
            if (toUsdPrice > 0 && fromUsdPrice > 0) {
                this.$data.toPrice = (toUsdPrice / fromUsdPrice).toFixed(8).replace(/\.?0+$/, '');
            }
        },
        highlightNext() {
            if (this.highlightedIndex < this.filteredAssets.length - 1) {
                this.highlightedIndex++;
            }
        },
        highlightPrev() {
            if (this.highlightedIndex > 0) {
                this.highlightedIndex--;
            }
        },
        selectHighlighted() {
            if (this.filteredAssets.length > 0) {
                this.selectAsset(this.filteredAssets[this.highlightedIndex]);
            }
        }
    }
}

function cryptoSearchTo() {
    return {
        search: '',
        cryptos: [],
        filteredCryptos: [],
        showDropdown: false,
        highlightedIndex: 0,
        async init() {
            this.cryptos = await fetchExchangeCryptos();
        },
        onFocus() {
            this.filterCryptos();
            this.showDropdown = true;
            this.highlightedIndex = 0;
        },
        onInput(value) {
            this.search = value.toUpperCase();
            this.filterCryptos();
            this.highlightedIndex = 0;
        },
        filterCryptos() {
            if (!this.search) {
                this.filteredCryptos = this.cryptos.slice(0, 10);
                return;
            }
            const term = this.search.toLowerCase();
            this.filteredCryptos = this.cryptos
                .filter(c => c.symbol.toLowerCase().includes(term) || c.name.toLowerCase().includes(term))
                .slice(0, 10);
        },
        selectCrypto(crypto) {
            this.search = crypto.symbol;
            this.$data.toSymbol = crypto.symbol;
            this.$data.toSymbolUsdPrice = crypto.price || 0;
            this.$data.toSymbolCoinId = crypto.name || '';
            this.calcPriceInFromAsset(crypto.price);
            this.showDropdown = false;
        },
        calcPriceInFromAsset(toUsdPrice) {
            if (!toUsdPrice || toUsdPrice <= 0) return;
            const fromUsdPrice = this.$data.fromSymbolUsdPrice || 0;
            if (fromUsdPrice > 0) {
                const priceInFromAsset = toUsdPrice / fromUsdPrice;
                this.$data.toPrice = priceInFromAsset.toFixed(8).replace(/\.?0+$/, '');
            }
        },
        onSymbolSelected(symbol) {
            const crypto = this.cryptos.find(c => c.symbol === symbol);
            if (crypto && crypto.price) {
                this.$data.toSymbolUsdPrice = crypto.price;
                this.$data.toSymbolCoinId = crypto.name || '';
                this.calcPriceInFromAsset(crypto.price);
            }
        },
        highlightNext() {
            if (this.highlightedIndex < this.filteredCryptos.length - 1) {
                this.highlightedIndex++;
            }
        },
        highlightPrev() {
            if (this.highlightedIndex > 0) {
                this.highlightedIndex--;
            }
        },
        selectHighlighted() {
            if (this.filteredCryptos.length > 0) {
                this.selectCrypto(this.filteredCryptos[this.highlightedIndex]);
            }
        }
    }
}

let holdingsData = {{.HoldingsJSON}};

async function refreshHoldings() {
    try {
        const response = await fetch('/api/ui/holdings');
        holdingsData = await response.json();
        window.dispatchEvent(new CustomEvent('holdings-updated'));
    } catch (e) {
        console.error('Failed to refresh holdings:', e);
    }
}

function exchangeModal() {
    return {
        open: false,
        isEdit: false,
        exchangeId: null,
        fromSymbol: '',
        fromAmount: '',
        toSymbol: '',
        toAmount: '',
        toPrice: '',
        toSymbolUsdPrice: 0,
        toSymbolCoinId: '',
        fromSymbolUsdPrice: 0,
        fee: '',
        feeCurrency: '',
        timestamp: '',
        notes: '',
        holdings: holdingsData,

        async init() {
            await fetchExchangeCryptos();
            window.addEventListener('holdings-updated', () => {
                this.holdings = holdingsData;
            });
        },

        get fromUsd() {
            const amount = parseFloat(this.fromAmount) || 0;
            return amount * this.fromSymbolUsdPrice;
        },

        get availableUsd() {
            const available = this.holdings[this.fromSymbol] || 0;
            return available * this.fromSymbolUsdPrice;
        },

        get toUsd() {
            const amount = parseFloat(this.toAmount) || 0;
            const usdPrice = this.toSymbolUsdPrice || 0;
            return amount * usdPrice;
        },

        get toValueInFrom() {
            const toAmt = parseFloat(this.toAmount) || 0;
            const toPrice = parseFloat(this.toPrice) || 0;
            if (toAmt > 0 && toPrice > 0) {
                return toAmt * toPrice;
            }
            return 0;
        },

        get exchangeRate() {
            const fromAmt = parseFloat(this.fromAmount) || 0;
            const toAmt = parseFloat(this.toAmount) || 0;
            if (toAmt > 0 && fromAmt > 0) {
                return fromAmt / toAmt;
            }
            return 0;
        },

        get canCalcToAmount() {
            const fromAmt = parseFloat(this.fromAmount) || 0;
            const toPrice = parseFloat(this.toPrice) || 0;
            return fromAmt > 0 && toPrice > 0 && this.toSymbol;
        },

        get canCalcToPrice() {
            const fromAmt = parseFloat(this.fromAmount) || 0;
            const toAmt = parseFloat(this.toAmount) || 0;
            return fromAmt > 0 && toAmt > 0 && this.toSymbol;
        },

        get estimatedToAmount() {
            const fromAmt = parseFloat(this.fromAmount) || 0;
            const toPrice = parseFloat(this.toPrice) || 0;
            if (fromAmt > 0 && toPrice > 0) {
                return fromAmt / toPrice;
            }
            return 0;
        },

        get estimatedToPrice() {
            const fromAmt = parseFloat(this.fromAmount) || 0;
            const toAmt = parseFloat(this.toAmount) || 0;
            if (fromAmt > 0 && toAmt > 0) {
                return fromAmt / toAmt;
            }
            return 0;
        },

        calcToAmount() {
            if (this.canCalcToAmount) {
                this.toAmount = this.estimatedToAmount.toFixed(8).replace(/\.?0+$/, '');
            }
        },

        calcToPrice() {
            if (this.canCalcToPrice) {
                this.toPrice = this.estimatedToPrice.toFixed(8).replace(/\.?0+$/, '');
            }
        },

        formatNumber(num) {
            if (num >= 1000000) return Math.round(num/1000) + 'K';
            if (num >= 1000) return Math.round(num).toLocaleString();
            if (num >= 1) return num.toLocaleString(undefined, { maximumFractionDigits: 2 });
            if (num >= 0.001) return num.toLocaleString(undefined, { maximumFractionDigits: 4 });
            return num.toLocaleString(undefined, { maximumFractionDigits: 8 });
        },

        formatUsd(num) {
            if (num >= 1000000) return Math.round(num/1000) + 'K';
            if (num >= 1000) return Math.round(num).toLocaleString();
            return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        },

        formatRate(num) {
            if (num >= 1) return num.toLocaleString(undefined, { maximumFractionDigits: 4 });
            return num.toLocaleString(undefined, { maximumFractionDigits: 8 });
        },

        calcRate() {
        },

        openAdd() {
            this.isEdit = false;
            this.exchangeId = null;
            this.fromSymbol = '';
            this.fromAmount = '';
            this.toSymbol = '';
            this.toAmount = '';
            this.toPrice = '';
            this.toSymbolUsdPrice = 0;
            this.toSymbolCoinId = '';
            this.fromSymbolUsdPrice = 0;
            this.fee = '';
            this.feeCurrency = '';
            this.timestamp = new Date().toISOString().slice(0, 16);
            this.notes = '';
            this.open = true;
        },

        openEdit(detail) {
            this.isEdit = true;
            this.exchangeId = detail.id;
            this.fromSymbol = detail.from_symbol;
            this.fromSymbolUsdPrice = getCryptoPrice(detail.from_symbol);
            this.fromAmount = detail.from_amount;
            this.toSymbol = detail.to_symbol;
            this.toSymbolUsdPrice = getCryptoPrice(detail.to_symbol);
            this.toSymbolCoinId = getCryptoCoinId(detail.to_symbol);
            this.toAmount = detail.to_amount;
            this.toPrice = '';
            this.fee = detail.fee || '';
            this.feeCurrency = detail.fee_currency || '';
            this.timestamp = detail.timestamp;
            this.notes = detail.notes || '';
            this.open = true;
        }
    }
}

function deleteExchangeModal() {
    return {
        open: false,
        exchangeId: null,
        openDelete(detail) {
            this.exchangeId = detail.id;
            this.open = true;
        },
        confirmDelete() {
            htmx.ajax('DELETE', '/partials/exchanges/delete/' + this.exchangeId, {
                target: '#exchanges-table-container',
                swap: 'innerHTML'
            }).then(() => {
                this.open = false;
                refreshHoldings();
                window.dispatchEvent(new CustomEvent('show-toast', {
                    detail: { message: 'Exchange deleted', type: 'success' }
                }));
            });
        }
    }
}
</script>
{{end}}
